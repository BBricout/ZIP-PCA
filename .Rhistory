myPCA <- nlopt_optimize_rank_cov(data, params, config)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
myPCA <- nlopt_optimize_rank_cov(data, params, config)
rm(list=ls())
library(Rcpp)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(PLNmodels)
library(missMDA)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
library(missForest)
summary(Y)
C <- C/sqrt(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
max(Y)
min(Y)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
n = 500 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
print(max(Y))
C <- scale(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/n
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- matrix(rnorm(p*q), nrow = p)
C
Z <- XB + (W %*% t(C))/n
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Z <- XB + (W %*% t(C))/sqrt(max(W %*% t(C)) - min(W %*% t(C)))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(C, res.PLNPCA$estim$C)
C.hat <- res.PLNPCA$estim$C
plot(t(C)%*%C, t(C.hat)%*%C.hat)
t(C)%*%C
plot(C%*%t(C), C.hat%*%t(C.hat))
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
n = 5000 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
C.hat <- res.PLNPCA$estim$C
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
rm(list=ls())
1+1
#--------------------Libraries-----------------------
source(file = "Fonctions/Fonction_PLNPCA_covariables.R")
plot(1:6, 1:6)
quit()
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
setwd("~/Documents/ZIP-PCA")
library(Rcpp)
library(PLNmodels)
setwd("~/Documents/ZIP-PCA") # A changer
library(Rcpp)
library(PLNmodels)
# seed <- .Random.seed
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIP.R')
source("codesSR/Functions/FunctionsZIPLNmiss.R")
source("codesSR/Functions/FunctionsZIPLNmissVec.R")
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
source("Data_create.R")
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
config$algorithm <- "MMA"
init <- InitZiPLN(data,q)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
mStep <- init$mStep ; eStep <- init$eStep
lb1 <- rep(-Inf, 2*d + q*(p+n))
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(1e-06, n * q))
config$lower_bounds <- lb
out_ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, params = params, config = config)
plot(out_ref$elboPath)
plot(true$mStep$gamma, out_ref$mStep$gamma) ; abline(0,1)
XD <- data$X%*%true$mStep$gamma
XD_ref <- data$X%*%out_ref$mStep$gamma
plot(XD, XD_ref) ; abline(0,1)
plot(true$mStep$beta, out_ref$mStep$beta) ; abline(0,1)
XB <- data$X%*%true$mStep$beta
XB_ref <- data$X%*%out_ref$mStep$beta
# XB_vem <- data$X%*%vem$mStep$betabetaXB_vem <- data$X%*%vem$mStep$beta
plot(XB_ref, XB) ; abline(0,1)
parmsInit <- c(mStep$gamma, mStep$beta, as.vector(mStep$C),
as.vector(t(eStep$M)), as.vector(t(eStep$S)))
Bobj <- function(parms, data){
params <- Parms2Params(parms=parms, data=data)
ElboB(data=data, params=params, tolXi = 1e-04)$obj
}
Bgrad <- function(parms, data){
params <- Parms2Params(parms=parms, data=data)
elbo <- ElboB(data=data, params=params, tolXi = 1e-04)
c(as.vector(elbo$gradD), as.vector(elbo$gradB), as.vector(elbo$gradC),
as.vector(t(elbo$gradM)), as.vector(t(elbo$gradS)))
}
Bfit <- optim(par=parmsInit, fn=Bobj, gr=Bgrad, data=data,
method='L-BFGS-B', control=list(fnscale=-1), lower = lb)
Bfit$value
out_ref$elbo
Y.logit <- ifelse(Y == 0, 0, 1)
boxplot(XD_ref ~ Y.logit)
Y.logit <- ifelse(Y == 0, 0, 1)
boxplot(XD_ref ~ Y.logit)
Y.logit <- ifelse(data$Y == 0, 0, 1)
boxplot(XD_ref ~ Y.logit)
dim(XD_ref)
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit)
out <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, params = params, config = config)
D.hat <- out$mStep$gamma
# Estimations
B.hat <- out$mStep$beta
D.hat <- out$mStep$gamma
C.hat <- out$mStep$C
M.hat <- out$eStep$M
S.hat <- out$eStep$S
XB <- VectorToMatrix(data$X %*% true$mStep$beta, n, p)
XB.hat <- VectorToMatrix(data$X %*% B.hat, n, p)
XD <- VectorToMatrix(data$X %*% true$mStep$gamma, n, p)
XD.hat <- VectorToMatrix(data$X %*% D.hat, n, p)
pred <- exp(XB.hat + M.hat %*% t(C.hat) + 0.5 * (S.hat*S.hat) %*% t(C.hat * C.hat))
?plot
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
Y.logit <- ifelse(data$Y == 0, 0, 1)
plot(log(1 + Y[Y =!0]), log(1 + pred[Y =! 0]), main = "Prediction")
plot(log(1 + data$Y[data$Y =!0]), log(1 + pred[data$Y =! 0]), main = "Prediction")
plot(log(1 + data$Y[data$Y =!0]), log(1 + pred[data$Y =! 0]), main = "Prediction")
data$Y[data$Y =!0]
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y =! 0]), main = "Prediction")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
par(mfrow=c(2, 3)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
config
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
setwd("~/Documents/ZIP-PCA") # A changer
library(Rcpp)
library(PLNmodels)
# seed <- .Random.seed
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIP.R')
source("codesSR/Functions/FunctionsZIPLNmiss.R")
source("codesSR/Functions/FunctionsZIPLNmissVec.R")
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
source("Data_create.R")
init <- InitZiPLN(data,q)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
mStep <- init$mStep ; eStep <- init$eStep
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(1e-06, n * q))
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb # Si tu veux voir les résultats sans donner la lb il ne faut pas la mettre dans config
out <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, params = params, config = config)
# Estimations
B.hat <- out$mStep$beta
D.hat <- out$mStep$gamma
C.hat <- out$mStep$C
M.hat <- out$eStep$M
S.hat <- out$eStep$S
XB <- VectorToMatrix(data$X %*% true$mStep$beta, n, p)
XB.hat <- VectorToMatrix(data$X %*% B.hat, n, p)
XD <- VectorToMatrix(data$X %*% true$mStep$gamma, n, p)
XD.hat <- VectorToMatrix(data$X %*% D.hat, n, p)
pred <- exp(XB.hat + M.hat %*% t(C.hat) + 0.5 * (S.hat*S.hat) %*% t(C.hat * C.hat))
Y.logit <- ifelse(data$Y == 0, 0, 1)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
setwd("~/Documents/ZIP-PCA") # A changer
library(Rcpp)
library(PLNmodels)
source("codesBB/UtilsBB.R")
source("Data_create.R")
sourceCpp("src/optim_rank_zip_log.cpp")
sourceCpp("src/optim_rank_ZIP_log.cpp")
init <- InitZiPLN(data,q)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
names(data)
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
sourceCpp("src/optim_rank_ZIP_log.cpp")
sourceCpp("src/optim_rank_ZIP_log.cpp")
init <- InitZiPLN(data,q)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
ElboB(data, params, tolXi)$objective
paramsLogS <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = log(as.matrix(init$eStep$S)))
ElboB(data, params, tolXi)$objective
ElboBLogS(data, paramsLogS, tolXi)$objective
paramsLogS <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
logS = log(as.matrix(init$eStep$S)))
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
ElboB(data, params, tolXi)$objective
ElboBLogS(data, paramsLogS, tolXi)$objective
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
setwd("~/Documents/ZIP-PCA") # A changer
library(Rcpp)
library(PLNmodels)
# seed <- .Random.seed
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIP.R')
source("codesSR/Functions/FunctionsZIPLNmiss.R")
source("codesSR/Functions/FunctionsZIPLNmissVec.R")
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
source("Data_create.R")
init <- InitZiPLN(data,q)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
mStep <- init$mStep ; eStep <- init$eStep
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(1e-06, n * q))
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
plot(init$mStep$beta, params$B) ; abline(0,1)
plot(init$mStep$gamma, params$D) ; abline(0,1)
plot(init$mStep$C, params$C) ; abline(0,1)
plot(init$eStep$M, params$M) ; abline(0,1)
plot(init$eStep$S, params$S) ; abline(0,1)
Belbo_grad <- ElboB(data, params, tolXi)
Selbo <- ELBO(data=data, mStep=mStep, eStep=eStep)
SgradS <- matrix(ElboGradVecS(Svec=as.vector(t(eStep$S)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradM <- matrix(ElboGradVecM(Mvec=as.vector(t(eStep$M)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradBeta <- ElboGradBeta(beta=mStep$beta, data=data, mStep=mStep, eStep=eStep)
SgradGamma <- ElboGradGamma(gamma=mStep$gamma, data=data, mStep=mStep, eStep=eStep)
SgradC <- as.matrix(ElboGradC(vecC=as.vector(mStep$C), data=data, mStep=mStep, eStep=eStep),p,q)
Belbo_grad$objective ; Selbo
plot(init$eStep$xi, Belbo_grad$xi) ; abline(0,1)
plot(Belbo_grad$gradB, SgradBeta) ; abline(0,1)
plot(Belbo_grad$gradD, SgradGamma) ; abline(0,1)
plot(Belbo_grad$gradC, SgradC) ; abline(0,1)
plot(Belbo_grad$gradM, SgradM) ; abline(0,1)
plot(Belbo_grad$gradS, SgradS) ; abline(0,1)
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(1e-06, n * q))
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb # Si tu veux voir les résultats sans donner la lb il ne faut pas la mettre dans config
config$maxeval <- 5
out <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, params = params, config = config)
# Estimations
B.hat <- out$mStep$beta
D.hat <- out$mStep$gamma
C.hat <- out$mStep$C
M.hat <- out$eStep$M
S.hat <- out$eStep$S
XB <- VectorToMatrix(data$X %*% true$mStep$beta, n, p)
XB.hat <- VectorToMatrix(data$X %*% B.hat, n, p)
XD <- VectorToMatrix(data$X %*% true$mStep$gamma, n, p)
XD.hat <- VectorToMatrix(data$X %*% D.hat, n, p)
pred <- exp(XB.hat + M.hat %*% t(C.hat) + 0.5 * (S.hat*S.hat) %*% t(C.hat * C.hat))
Y.logit <- ifelse(data$Y == 0, 0, 1)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD_ref, n, p) ~ Y.logit, main = "Estimation")
boxplot(VectorToMatrix(XD.hat, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-04
config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb # Si tu veux voir les résultats sans donner la lb il ne faut pas la mettre dans config
out <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, params = params, config = config)
# Estimations
B.hat <- out$mStep$beta
D.hat <- out$mStep$gamma
C.hat <- out$mStep$C
M.hat <- out$eStep$M
S.hat <- out$eStep$S
XB <- VectorToMatrix(data$X %*% true$mStep$beta, n, p)
XB.hat <- VectorToMatrix(data$X %*% B.hat, n, p)
XD <- VectorToMatrix(data$X %*% true$mStep$gamma, n, p)
XD.hat <- VectorToMatrix(data$X %*% D.hat, n, p)
pred <- exp(XB.hat + M.hat %*% t(C.hat) + 0.5 * (S.hat*S.hat) %*% t(C.hat * C.hat))
Y.logit <- ifelse(data$Y == 0, 0, 1)
par(mfrow=c(2, 3))
plot(out$elboPath, main = "ELBO path")
plot(XD, XD.hat, main = "Estimation de la logistique") ; abline(0,1)
plot(XB, XB.hat, main = "Estimation des régresseurs") ; abline(0,1)
boxplot(VectorToMatrix(XD, n, p) ~ Y.logit, main = "True")
boxplot(VectorToMatrix(XD.hat, n, p) ~ Y.logit, main = "Estimation")
plot(log(1 + data$Y[data$Y !=0]), log(1 + pred[data$Y != 0]), main = "Prediction") ; abline(0,1)
