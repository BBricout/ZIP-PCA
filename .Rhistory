geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
n = 200 # Nombre d'observation
p = 5 # Nombre de variables
d = 1 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,n),matrix(rnorm(n*d), nrow = n)) # Matrice de covariables n*d+1
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- matrix(0,d+1,p) # Coefficients des covariables d+1*p
B[1,] <- c(3,2,4,2,3)
B[2,] <- c(0.6, 0.5, 0.4, 0.4, 0.2)
C <- matrix(0, p, q) # Coefficients des variables latentes p*q
C[,1] <- c(0.2, 0.5, 0.4, 0.2, 0.1)
C[,2] <- c(0.4, 0.2, 0.1, 0.3, 0.2)
print(C%*%t(C))
Z <- X %*% B + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
Y.na <- prodNA(Y, 0.3)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
config <- PLNPCA_param()$config_optim
# C.init <- matrix(0, p, q)
# M.init <- matrix(0, n, q)
# S.init <- matrix(0, n, q)
#
#
# params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
#
#
# source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLN_missing_data.R")
#
vecX <- matrix(rnorm(n*p*2), nrow = n*p, ncol = 2)
vecY <- MatrixToVector(Y)
fit <- lm(log(1 + vecY) ~ -1 + vecX)
B.init <- as.matrix(fit$coefficients)
res.vec <- fit$residuals
res.full <- ifelse(is.na(vecY), 0, res.vec)
res.mat <- VectorToMatrix(res.full, n, p)
svdM <- svd(res.mat, nu = q, nv = p)
C.init  <- svdM$v[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q)/sqrt(n)
M.init  <- svdM$u[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q) %*% t(svdM$v[1:q, 1:q, drop = FALSE])
S.init  <- matrix(0.1, n, q)
params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = vecX, O = O, w = w)
myPCA <- nlopt_optimize_rank_cov(data, params, config)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
myPCA <- nlopt_optimize_rank_cov(data, params, config)
rm(list=ls())
library(Rcpp)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(PLNmodels)
library(missMDA)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
library(missForest)
summary(Y)
C <- C/sqrt(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
max(Y)
min(Y)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
n = 500 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
print(max(Y))
C <- scale(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/n
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- matrix(rnorm(p*q), nrow = p)
C
Z <- XB + (W %*% t(C))/n
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Z <- XB + (W %*% t(C))/sqrt(max(W %*% t(C)) - min(W %*% t(C)))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(C, res.PLNPCA$estim$C)
C.hat <- res.PLNPCA$estim$C
plot(t(C)%*%C, t(C.hat)%*%C.hat)
t(C)%*%C
plot(C%*%t(C), C.hat%*%t(C.hat))
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
n = 5000 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
C.hat <- res.PLNPCA$estim$C
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
rm(list=ls())
1+1
#--------------------Libraries-----------------------
source(file = "Fonctions/Fonction_PLNPCA_covariables.R")
library(Rcpp)
library(Matrix)
library(mvtnorm)
library(stringr)
library(ggplot2)
library(matrixcalc)
library(missForest)
local.dir = getwd()
sourceCpp(file.path(local.dir,"src/optim_rank_ZIP.cpp"))
n <- 300
p <- 30
d <- 2
setwd("~/Documents/ZIP-PCA")
local.dir = getwd()
sourceCpp(file.path(local.dir,"src/optim_rank_ZIP.cpp"))
n <- 300
p <- 30
d <- 2
q <- 3
X <- cbind(c(rep(1, n*p)), matrix(rnorm(n*p*d), nrow = n*p))
B <- c(2, 1, 0.5)
D <- c(-0.5, 0.5, -0.7)
mu <- VectorToMatrix(X%*%B, n, p)
nu <- VectorToMatrix(X%*%D, n, p)
Prob <- plogis(nu)
U <- matrix(rbinom(n*p, p = Prob, size = 1), nrow = n)
W <- matrix(rnorm(n*q), nrow = n)/2
C <- matrix(rnorm(p*q,0,1), nrow = p)/ sqrt(q)
var(X%*%B)
var(MatrixToVector(W%*%t(C)))
Lambda <- exp(mu + W %*% t(C))
Z <- matrix(rpois(n*p, lambda = Lambda), nrow = n)
Y <- ifelse(U == 0, 0, Z)
Y.na <- prodNA(Y, 0.5)
range(Y)
Init_ZIP <- function(Y, X, q){
n <- nrow(Y)
p <- ncol(Y)
vecY <- MatrixToVector(Y)
U <- ifelse(Y == 0, 0, 1)
fit.logit <- glm(vec(U) ~ -1 + X, family = "binomial", na.action = na.exclude)
D <- as.matrix(fit.logit$coefficients)
fit <- lm(log(1 + vecY) ~ -1 + X, na.action = na.exclude)
B <- as.matrix(fit$coefficients)
res.mat <- VectorToMatrix(fit$residuals, n, p)
svdM <- svd(res.mat, nu = q, nv = p)
C <- svdM$v[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q)/sqrt(n)
M  <- svdM$u[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q) %*% t(svdM$v[1:q, 1:q, drop = FALSE])
S <- matrix(0.1, n, q)
return(list(B = B, D = D, C = C, M = M, S = S))
}
dataNA <- list(Y = ifelse(is.na(Y.na), 0, Y),
R = ifelse(is.na(Y.na), 0, 1),
X = X)
data <- list(Y = Y, R = matrix(1, n, p), X = X)
# data2 <- list(Y = Z, R = matrix(1, n, p), X = X,
#               O = matrix(0, nrow = n, ncol = p),
#               w = rep(1,n))
params <- Init_ZIP(Y, X, q)
config <- PLNPCA_param()$config_optim
library(Rcpp)
library(Matrix)
library(mvtnorm)
library(stringr)
library(ggplot2)
library(matrixcalc)
library(missForest)
config <- PLNPCA_param()$config_optim
library(PLNmodels)
out <- nlopt_optimize_ZIP(data, params, config)
elbo <- out$objective_values
# data2 <- list(Y = Z, R = matrix(1, n, p), X = X,
#               O = matrix(0, nrow = n, ncol = p),
#               w = rep(1,n))
params <- Init_ZIP(Y, X, q)
config <- PLNPCA_param()$config_optim
out <- nlopt_optimize_ZIP(data, params, config)
elbo <- out$objective_values
plot(elbo, type='b', xlab='iter', ylim=quantile(elbo, probs=c(0.1, 0.9)))
sigma <- C%*%t(C)
sigma.out <- out$C%*%t(out$C)
plot(X%*%B, X%*%out$B, main = "B") ; abline(0,1)
plot(X%*%D, X%*%out$D, main = "D") ; abline(0,1)
plot(sigma, sigma.out, main = "sigma") ; abline(0,1)
Z.ref <- W%*%t(C)
Z.out <- out$M%*%t(out$C)
plot(Z.ref, Z.out, main = "Z") ; abline(0,1)
cov <- 1/n * t(out$M)%*%out$M + diag(colMeans(out$S))
plot(Y, out$xi * out$A) ; abline(0,1)
cov
plot(Y, out$xi * out$A) ; abline(0,1)
# Work directory
wd <- "~/Documents"
setwd(wd)
# Data directory
data.directory <- file.path(wd, "Data")
# Fonctions directory
fun.directory <- file.path(wd,"PLNPCA_missing_data/Fonctions/Fonction_PLNPCA_covariables.R")
library(PLNmodels)
library(mvabund)
library(gllvm)
library(ggplot2)
library(lori)
library(missForest)
library(patchwork)
source(fun.directory)
install.packages("missMDA")
# Fonctions directory
fun.directory <- file.path(wd,"PLNPCA_missing_data/Fonctions/Fonction_PLNPCA_covariables.R")
library(PLNmodels)
library(mvabund)
library(gllvm)
library(ggplot2)
library(lori)
library(missForest)
library(patchwork)
source(fun.directory)
load(file.path(data.directory, "Colvert/Colvert_data.Rdata"))
Y.col <- Colvert$Y
Row.col <- Colvert$Row
Col.col <- Colvert$Col
Inter.col <- MatrixToVector(Colvert$Inter)
head(Y.col)
mean(Y.col == 0)
head(Row.col)
head(Col.col)
head(Inter.col)
INter.col
Inter.col
n.col <- nrow(Y.col)
p.col <- ncol(Y.col)
X.col <- covmat(n.col, p.col, Row.col, Col.col, Inter.col)
head(X.col)
save.dir <- "~/Documents/ZIP-PCA"
write.csv(Y.col, file = file.path(save.dir, "Colvert_count.csv"))
write.csv(X.col, file = file.path(save.dir, "Colvert_covariate.csv"))
load(file.path(data.directory, "lori_northern_shoveler/Souchet_data.Rdata"))
Y.sou <- Souchet$Y
Row.sou <- Souchet$Row
Col.sou <- Souchet$Col
Inter.sou <- Souchet$Inter
n.sou <- nrow(Y.sou)
p.sou <- ncol(Y.sou)
X.sou <- scale(covmat(n.sou, p.sou, Row.sou, Col.sou, Inter.sou))
write.csv(Y.sou, file = file.path(save.dir, "Souchet_count.csv"))
write.csv(X.sou, file = file.path(save.dir, "Souchet_covariate.csv"))
head(X.sou)
rm(list=ls())
library(Rcpp)
library(Matrix)
library(mvtnorm)
library(stringr)
library(ggplot2)
library(matrixcalc)
library(missForest)
library(PLNmodels)
local.dir = getwd()
sourceCpp(file.path(local.dir,"src/optim_rank_ZIP.cpp"))
n <- 300
setwd("~/Documents/ZIP-PCA")
local.dir = getwd()
sourceCpp(file.path(local.dir,"src/optim_rank_ZIP.cpp"))
n <- 300
p <- 30
d <- 2
q <- 3
X <- cbind(c(rep(1, n*p)), matrix(rnorm(n*p*d), nrow = n*p))
B <- c(2, 1, 0.5)
D <- c(-0.5, 0.5, -0.7)
mu <- VectorToMatrix(X%*%B, n, p)
nu <- VectorToMatrix(X%*%D, n, p)
Prob <- plogis(nu)
U <- matrix(rbinom(n*p, p = Prob, size = 1), nrow = n)
W <- matrix(rnorm(n*q), nrow = n)/2
C <- matrix(rnorm(p*q,0,1), nrow = p)/ sqrt(q)
var(X%*%B)
var(MatrixToVector(W%*%t(C)))
Lambda <- exp(mu + W %*% t(C))
Z <- matrix(rpois(n*p, lambda = Lambda), nrow = n)
Y <- ifelse(U == 0, 0, Z)
D <- c(0.5, -0.5, -0.7)
mu <- VectorToMatrix(X%*%B, n, p)
nu <- VectorToMatrix(X%*%D, n, p)
Prob <- plogis(nu)
U <- matrix(rbinom(n*p, p = Prob, size = 1), nrow = n)
W <- matrix(rnorm(n*q), nrow = n)/2
C <- matrix(rnorm(p*q,0,1), nrow = p)/ sqrt(q)
var(X%*%B)
var(MatrixToVector(W%*%t(C)))
Lambda <- exp(mu + W %*% t(C))
Z <- matrix(rpois(n*p, lambda = Lambda), nrow = n)
Y <- ifelse(U == 0, 0, Z)
Y.na <- prodNA(Y, 0.5)
range(Y)
Init_ZIP <- function(Y, X, q){
n <- nrow(Y)
p <- ncol(Y)
vecY <- MatrixToVector(Y)
U <- ifelse(Y == 0, 0, 1)
fit.logit <- glm(vec(U) ~ -1 + X, family = "binomial", na.action = na.exclude)
D <- as.matrix(fit.logit$coefficients)
fit <- lm(log(1 + vecY) ~ -1 + X, na.action = na.exclude)
B <- as.matrix(fit$coefficients)
res.mat <- VectorToMatrix(fit$residuals, n, p)
svdM <- svd(res.mat, nu = q, nv = p)
C <- svdM$v[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q)/sqrt(n)
M  <- svdM$u[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q) %*% t(svdM$v[1:q, 1:q, drop = FALSE])
S <- matrix(0.1, n, q)
return(list(B = B, D = D, C = C, M = M, S = S))
}
dataNA <- list(Y = ifelse(is.na(Y.na), 0, Y),
R = ifelse(is.na(Y.na), 0, 1),
X = X)
data <- list(Y = Y, R = matrix(1, n, p), X = X)
# data2 <- list(Y = Z, R = matrix(1, n, p), X = X,
#               O = matrix(0, nrow = n, ncol = p),
#               w = rep(1,n))
params <- Init_ZIP(Y, X, q)
config <- PLNPCA_param()$config_optim
out <- nlopt_optimize_ZIP(data, params, config)
elbo <- out$objective_values
plot(elbo, type='b', xlab='iter', ylim=quantile(elbo, probs=c(0.1, 0.9)))
sigma <- C%*%t(C)
sigma.out <- out$C%*%t(out$C)
plot(X%*%B, X%*%out$B, main = "B") ; abline(0,1)
plot(X%*%D, X%*%out$D, main = "D") ; abline(0,1)
plot(sigma, sigma.out, main = "sigma") ; abline(0,1)
Z.ref <- W%*%t(C)
Z.out <- out$M%*%t(out$C)
plot(Z.ref, Z.out, main = "Z") ; abline(0,1)
cov <- 1/n * t(out$M)%*%out$M + diag(colMeans(out$S))
plot(Y, out$xi * out$A) ; abline(0,1)
# M <- params$M
# M <- params$M
# S <- params$S
# M <- params$M
# S <- params$S
#
