C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
XB
exp(XB)
plot(exp(XB))
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
plot(exp(XB))
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
plot(Y)
Y
plot(Y[,2], Y[,3])
library(lori)
install.packages =("lori")
library(lori)
install.packages =("lori")
install.packages("lori")
## covariates
m1 <- 30 # number of rows
m2 <- 10 # number of columns
K1 <- 2 # number of row covariates
K2 <- 2 # number of column covariates
K3 <- 3 # number of (rowxcolumn) covariates
R <- matrix(rnorm(m1*K1), nrow=m1) # matrix of row covariates
C <- matrix(rnorm(m2*K2), nrow=m2) # matrix of column covariates
E <- matrix(rnorm(m1*m2*K3), nrow=m1*m2) # matrix of  (rowxcolumn) covariates
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
## covariates
n <- 30 # number of rows
p <- 10 # number of columns
d1 <- 2 # number of row covariates
d2 <- 2 # number of column covariates
d3 <- 3 # number of (rowxcolumn) covariates
R <- matrix(rnorm(m1*K1), nrow=m1) # matrix of row covariates
C <- matrix(rnorm(m2*K2), nrow=m2) # matrix of column covariates
R <- matrix(rnorm(n*d1), nrow=n) # matrix of row covariates
C <- matrix(rnorm(p*d2), nrow=p) # matrix of column covariates
E <- matrix(rnorm(n*p*d3), nrow=n*p) # matrix of  (rowxcolumn) covariates
U <- covmat(n, p, R, C, E)
U <- scale(U)
U
alpha0 <- rep(0,n)
alpha0[1:6] <- 1
beta0 <- rep(0, p)
beta0[1:4] <- 1
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
res.lori <- lori(Y, X, lambda1, lambda2)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
res.lori
names(lori)
names(res.lori)
res.lori$epsilon
res.lori$alpha
res.lori$beta
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
res.PLNPCA$estim$B
plot(Y, res.PLNPCA$Y.hat)
plot(Y, res.PLNPCA$Y.hat);abline(0,1)
Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
hist(Y)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
plot(Y, res.PLNPCA$Y.hat); abline(0,1)
res.PLNPCA$estim$B
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
n = 200 # Nombre d'observation
p = 5 # Nombre de variables
d = 1 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,n),matrix(rnorm(n*d), nrow = n)) # Matrice de covariables n*d+1
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- matrix(0,d+1,p) # Coefficients des covariables d+1*p
B[1,] <- c(3,2,4,2,3)
B[2,] <- c(0.6, 0.5, 0.4, 0.4, 0.2)
C <- matrix(0, p, q) # Coefficients des variables latentes p*q
C[,1] <- c(0.2, 0.5, 0.4, 0.2, 0.1)
C[,2] <- c(0.4, 0.2, 0.1, 0.3, 0.2)
print(C%*%t(C))
Z <- X %*% B + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
Y.na <- prodNA(Y, 0.3)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
config <- PLNPCA_param()$config_optim
# C.init <- matrix(0, p, q)
# M.init <- matrix(0, n, q)
# S.init <- matrix(0, n, q)
#
#
# params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
#
#
# source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLN_missing_data.R")
#
vecX <- matrix(rnorm(n*p*2), nrow = n*p, ncol = 2)
vecY <- MatrixToVector(Y)
fit <- lm(log(1 + vecY) ~ -1 + vecX)
B.init <- as.matrix(fit$coefficients)
res.vec <- fit$residuals
res.full <- ifelse(is.na(vecY), 0, res.vec)
res.mat <- VectorToMatrix(res.full, n, p)
svdM <- svd(res.mat, nu = q, nv = p)
C.init  <- svdM$v[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q)/sqrt(n)
M.init  <- svdM$u[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q) %*% t(svdM$v[1:q, 1:q, drop = FALSE])
S.init  <- matrix(0.1, n, q)
params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = vecX, O = O, w = w)
myPCA <- nlopt_optimize_rank_cov(data, params, config)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
myPCA <- nlopt_optimize_rank_cov(data, params, config)
rm(list=ls())
library(Rcpp)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(PLNmodels)
library(missMDA)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
library(missForest)
summary(Y)
C <- C/sqrt(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
max(Y)
min(Y)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
n = 500 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
print(max(Y))
C <- scale(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/n
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- matrix(rnorm(p*q), nrow = p)
C
Z <- XB + (W %*% t(C))/n
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Z <- XB + (W %*% t(C))/sqrt(max(W %*% t(C)) - min(W %*% t(C)))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(C, res.PLNPCA$estim$C)
C.hat <- res.PLNPCA$estim$C
plot(t(C)%*%C, t(C.hat)%*%C.hat)
t(C)%*%C
plot(C%*%t(C), C.hat%*%t(C.hat))
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
n = 5000 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
C.hat <- res.PLNPCA$estim$C
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
rm(list=ls())
1+1
#--------------------Libraries-----------------------
source(file = "Fonctions/Fonction_PLNPCA_covariables.R")
plot(1:6, 1:6)
quit()
setwd("~/Documents/ZIP-PCA")
source("FunctionsBB.R")
n <- 300
p <- 30
d <- 2
q <- 3
X <- cbind(c(rep(1, n*p)), matrix(rnorm(n*p*d), nrow = n*p))
B <- c(0.5, rnorm(d))
B
D <-  c(2, -1, 3)
mu <- VectorToMatrix(X%*%B, n, p)
nu <- VectorToMatrix(X%*%D, n, p)
Prob <- plogis(nu)
U <- matrix(rbinom(n*p, p = Prob, size = 1), nrow = n)
plot(nu, U)
lines(sort(nu), plogis(sort(nu)))
boxplot(nu ~ U)
W <- matrix(rnorm(n*q), nrow = n)
C <- matrix(rnorm(p*q,0,1), nrow = p)/ sqrt(q)
var(X%*%B)
var(MatrixToVector(W%*%t(C)))
Lambda <- exp(mu + W %*% t(C))
Z <- matrix(rpois(n*p, lambda = Lambda), nrow = n)
Y <- ifelse(U == 0, 0, Z)
range(Y)
data <- list(Y = Y, R = R, X = X) ; params <- Init_ZIP(Y, X, q)
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-4
config$algorithm <- "MMA"
sourceCpp(file = "src/optim_rank_ZIP.cpp")
out_ref <- nlopt_optimize_ZIP(data, params, config, tolXi)
out_ref$objective_values[length(out_ref$objective_values)]
sourceCpp(file = "src/optim_rank_ZIP.cpp")
out_ref <- nlopt_optimize_ZIP(data, params, config, tolXi)
data <- list(Y = Y, R = R, X = X) ; params <- Init_ZIP(Y, X, q)
R <- ifelse(is.na(Y), 0, 1)
range(Y)
data <- list(Y = Y, R = R, X = X) ; params <- Init_ZIP(Y, X, q)
config <- PLNPCA_param()$config_optim ; tolXi <- 1e-4
config$algorithm <- "MMA"
sourceCpp(file = "src/optim_rank_ZIP.cpp")
out_ref <- nlopt_optimize_ZIP(data, params, config, tolXi)
out_ref$objective_values[length(out_ref$objective_values)]
sourceCpp("src/optim_rank_ZIP_lb.cpp")
vec1 <- rep(0, 2*d + q*(p+n))
vec1
lb1 <- rep(0, 2*d + q*(p+n))
1e-04
lb2 <- rep(1e-04, n * q)
lb <- c(lb1, lb2)
lb
lb1 <- rep(-Inf, 2*d + q*(p+n))
lb2 <- rep(1e-04, n * q)
lb <- c(lb1, lb2)
lb
sourceCpp("src/optim_rank_ZIP_lb.cpp")
config$lower_bounds <- lb
sourceCpp("src/optim_rank_ZIP_lb.cpp")
out_lb <- nlopt_optimize_ZIP_lb(data, params, config, tolXi)
sourceCpp("src/optim_rank_ZIP_lb.cpp")
out_lb <- nlopt_optimize_ZIP_lb(data, params, config, tolXi)
length(lb)
lb1 <- rep(-Inf, 2*d + q*(p+n) + 2)
lb2 <- rep(1e-04, n * q)
lb <- c(lb1, lb2)
sourceCpp("src/optim_rank_ZIP_lb.cpp")
config$lower_bounds <- lb
out_lb <- nlopt_optimize_ZIP_lb(data, params, config, tolXi)
out_lb$objective_values[length(out_lb$objective_values)]
out_ref$objective_values[length(out_ref$objective_values)]
out_ref$objective_values
out_lb$objective_values
