config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
############################# Missing data
#data$Y.na <- prodNA(data$Y, 0.01)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[1,]==0)
data$Y.na[1,w[1]] = NA
data$Y.na[1:10,]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-w,]
databis$Y.na <- data$Y.na[-w,]
databis$logFactY <- data$logFactY[-w,]
pastis <- which(data$ij[,1] %in% w)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-w,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(w))), rep(tolS, (n-length(w)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
#setwd("~/Documents/ZIP-PCA")
library(Rcpp)
library(PLNmodels)
library(missForest)
#---------- Functions SR
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLNmiss.R')
source('codesSR/Functions/FunctionsZIP.R')
#--- Codes BB
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
###################################################"
#--- Simulate Données
#####################################################
# Parms: many small sims
n <- 1000; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
seed <- proc.time(); set.seed(seed)
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
tolXi <- 1e-04 ; tolS <- 1e-06
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(tolS, n * q))
config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
############################# Missing data
#data$Y.na <- prodNA(data$Y, 0.01)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[1,]==0)
data$Y.na[1,w[1]] = NA
data$Y.na[1:10,]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-w,]
databis$Y.na <- data$Y.na[-w,]
databis$logFactY <- data$logFactY[-w,]
pastis <- which(data$ij[,1] %in% w)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-w,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(w))), rep(tolS, (n-length(w)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
#setwd("~/Documents/ZIP-PCA")
library(Rcpp)
library(PLNmodels)
library(missForest)
#---------- Functions SR
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLNmiss.R')
source('codesSR/Functions/FunctionsZIP.R')
#--- Codes BB
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
###################################################"
#--- Simulate Données
#####################################################
# Parms: many small sims
n <- 1000; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
seed <- proc.time(); set.seed(seed)
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
tolXi <- 1e-04 ; tolS <- 1e-06
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(tolS, n * q))
config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
############################# Missing data
#data$Y.na <- prodNA(data$Y, 0.01)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[1,]==0)
data$Y.na[1,w[1]] = NA
data$Y.na[1:10,]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-w,]
databis$Y.na <- data$Y.na[-w,]
databis$logFactY <- data$logFactY[-w,]
pastis <- which(data$ij[,1] %in% w)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-w,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(w))), rep(tolS, (n-length(w)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
########################## load data ################
source("Data_create.R")
save(data,true,file="ourfile.Rdata")
rm(list=ls())
load(file='ourfile.Rdata')
################################
# seed <- .Random.seed
library(Rcpp)
library(PLNmodels)
library(missForest)
#--- Codes step
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIP.R')
source("codesSR/Functions/FunctionsZIPLNmiss.R")
source("codesSR/Functions/FunctionsZIPLNmissVec.R")
#----- Codes barbara
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
data$Y.na <- prodNA(data$Y, 0.1)
data$R <- data$Omega <- ifelse(is.na(data$Y.na), 0,1)
#names(data)
# databis <- list()
# databis$Y <- data$Y[-51,]
# databis$logFactY <- data$logFactY[-51,]
#
# pastis <- which(data$ij[,1]==51)
# databis$X <- data$X[-pastis,]
# databis$Omega <- data$Omega[-51,]
# databis$R <- databis$Omega
# data<- databis
n <- nrow(data$Y)
p <- ncol(data$Y)
q <- ncol(true$eStep$M)
d <- ncol(data$X)
################### INIT with méthode de stéphane
tolXi <- 1e-04
initS <- 1e-01
#-----------init Stephane
init <- InitZiPLN(data,q,tolXi,initS)
params <- list(B = as.matrix(init$mStep$beta),
D = as.matrix(init$mStep$gamma),
C = as.matrix(init$mStep$C),
M = as.matrix(init$eStep$M),
S = as.matrix(init$eStep$S))
Belbo_grad <- ElboB(data, params, tolXi)
#---------- Stephane
mStep <- init$mStep ; eStep <- init$eStep ;
Selbo <- ELBO(data=data, mStep=mStep, eStep=eStep)
SgradS <- matrix(ElboGradVecS(Svec=as.vector(t(eStep$S)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradM <- matrix(ElboGradVecM(Mvec=as.vector(t(eStep$M)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradBeta <- ElboGradBeta(beta=mStep$beta, data=data, mStep=mStep, eStep=eStep)
SgradGamma <- ElboGradGamma(gamma=mStep$gamma, data=data, mStep=mStep, eStep=eStep)
SgradC <- as.matrix(ElboGradC(vecC=as.vector(mStep$C), data=data, mStep=mStep, eStep=eStep),p,q)
plot(Belbo_grad$xi, init$eStep$xi)
Selbo <- ELBO(data=data, mStep=mStep, eStep=eStep)
SgradS <- matrix(ElboGradVecS(Svec=as.vector(t(eStep$S)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradM <- matrix(ElboGradVecM(Mvec=as.vector(t(eStep$M)), data=data, mStep=mStep, eStep=eStep),n, q, byrow=TRUE)
SgradBeta <- ElboGradBeta(beta=mStep$beta, data=data, mStep=mStep, eStep=eStep)
SgradGamma <- ElboGradGamma(gamma=mStep$gamma, data=data, mStep=mStep, eStep=eStep)
SgradC <- as.matrix(ElboGradC(vecC=as.vector(mStep$C), data=data, mStep=mStep, eStep=eStep),p,q)
#
Belbo_grad$objective ; Selbo
myrow <- random(1:500,1)
myrow <- sample(1:500,1)
myrow
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[myrow,]==0)
myrow
w <- which(data$Y[myrow,]==0)
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
#setwd("~/Documents/ZIP-PCA")
library(Rcpp)
library(PLNmodels)
library(missForest)
#---------- Functions SR
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLNmiss.R')
source('codesSR/Functions/FunctionsZIP.R')
#--- Codes BB
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
###################################################"
#--- Simulate Données
#####################################################
# Parms: many small sims
n <- 1000; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
seed <- proc.time(); set.seed(seed)
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
tolXi <- 1e-04 ; tolS <- 1e-06
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(tolS, n * q))
config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
############################# Missing data
#data$Y.na <- prodNA(data$Y, 0.01)
myrow <- sample(1:500,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,w[1]] = NA
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,w[1]] = NA
data$Y.na[myrow-5,myrow+5,]
myrow <- sample(6:450,1)
myrow
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
w <- which(data$Y[myrow,]==0)
w
data$Y.na[myrow,w[1]] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
w
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,4] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-w,]
databis$Y.na <- data$Y.na[-w,]
databis$logFactY <- data$logFactY[-w,]
pastis <- which(data$ij[,1] %in% w)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-w,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(w))), rep(tolS, (n-length(w)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
databis <- list()
databis$Y <- data$Y[-myrow,]
databis$Y.na <- data$Y.na[-myrow,]
databis$logFactY <- data$logFactY[-myrow,]
pastis <- which(data$ij[,1] %in% myrow)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-myrow,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(w))), rep(tolS, (n-length(w)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(myrow))), rep(tolS, (n-length(myrow)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
out.na.databis$elboPath
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1:10] = NA
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1:10] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1:10] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
library(Rcpp)
library(PLNmodels)
library(missForest)
#---------- Functions SR
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLNmiss.R')
source('codesSR/Functions/FunctionsZIP.R')
#--- Codes BB
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
# Parms: many small sims
n <- 1000; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
seed <- proc.time(); set.seed(seed)
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
tolXi <- 1e-04 ; tolS <- 1e-06
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(tolS, n * q))
config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1:10] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-myrow,]
databis$Y.na <- data$Y.na[-myrow,]
databis$logFactY <- data$logFactY[-myrow,]
pastis <- which(data$ij[,1] %in% myrow)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-myrow,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(myrow))), rep(tolS, (n-length(myrow)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
out.na.databis$elboPath
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1] = NA
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
#setwd("~/Documents/ZIP-PCA")
library(Rcpp)
library(PLNmodels)
library(missForest)
#---------- Functions SR
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLNmiss.R')
source('codesSR/Functions/FunctionsZIP.R')
#--- Codes BB
source("codesBB/FunctionsBB.R")
source("codesBB/UtilsBB.R")
###################################################"
#--- Simulate Données
#####################################################
# Parms: many small sims
n <- 1000; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
seed <- proc.time(); set.seed(seed)
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
tolXi <- 1e-04 ; tolS <- 1e-06
lb <- c(rep(-Inf, 2*d + q*(p+n)), rep(tolS, n * q))
config <- PLNPCA_param()$config_optim
config$maxeval = 1000
# config$algorithm <- "MMA" # Par défaut dans config c'est "CCSAQ"
config$lower_bounds <- lb
##################### NON missing data
out.ref <- Miss.ZIPPCA(Y = data$Y, X = data$X, q, config = config)
#--------------- ELBO
par(mfrow=c(1, 1))
plot(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
myrow <- sample(6:450,1)
data$Y.na <- data$Y#prodNA(data$Y, 0.01)
#w <- which(data$Y[myrow,]==0)
data$Y.na[myrow,1] = NA
data$Y.na[(myrow-5):(myrow+5),]
data$Y[(myrow-5):(myrow+5),]
out.na <- Miss.ZIPPCA(Y = data$Y.na, X = data$X, q, config = config)
#----------------- remove the corresponding missing row
w <-1
databis <- list()
databis$Y <- data$Y[-myrow,]
databis$Y.na <- data$Y.na[-myrow,]
databis$logFactY <- data$logFactY[-myrow,]
pastis <- which(data$ij[,1] %in% myrow)
databis$X <- data$X[-pastis,]
databis$Omega <- data$Omega[-myrow,]
databis$R <- databis$Omega
config$lower_bounds <- c(rep(-Inf, 2*d + q*(p+n-length(myrow))), rep(tolS, (n-length(myrow)) * q))
out.na.databis <- Miss.ZIPPCA(Y = databis$Y.na, X = databis$X, q, config = config)
out.na.databis$elbo
plot(out.na$elboPath[out.na$elboPath > out.na$elboPath[1]],type='l', main = "ELBO path",ylab='ELBO',xlab='iter')
lines(out.ref$elboPath[out.ref$elboPath > out.ref$elboPath[1]],col='red')
lines(out.na.databis$elboPath[out.na.databis$elboPath > out.na.databis$elboPath[1]],col='green')
out.na.databis$elboPath
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
library(Rcpp)
library(PLNmodels)
# seed <- .Random.seed
source('codesSR/Functions/FunctionsUtils.R')
source('codesSR/Functions/FunctionsZIPLN.R')
source('codesSR/Functions/FunctionsZIP.R')
simDir <- 'SimulationsBB/datasim/'
# Parms: many small sims
n <- 100; d <- 5; p <- 10; q <- 2
baseSimName <- 'ZiPLNsim'
seedList <- 1:10; seedNb <- length(seedList)
obsList <- c(1, 0.99, 0.95, 0.9, 0.8, 0.7, 0.6, 0.5); obsNb <- length(obsList)
#X0 <- NULL
# Same X for all
seedX <- 1; set.seed(seedX)
X0 <- matrix(rnorm(n*p*d), n*p, d); X0[, 1] <- 1;
baseSimName <- paste0(baseSimName, '-sameX', seedX)
#############################################################
set.seed(1)
seed = 1
simParmsFull <- paste0('-n', n, '-d', d, '-p', p, '-q', q, '-seed', seed)
simNameFull <- paste0(baseSimName, simParmsFull)
simFileFull <- paste0(simDir, simNameFull, '-noMiss.Rdata')
sim <- SimZiPLN(n=n, p=p, d=d, q=q, X=X0)
data <- list(X=sim$X, Y=sim$Y,  ij=sim$ij, logFactY=lgamma(sim$Y+1))
true <- list(mStep=list(gamma=sim$gamma, beta=sim$beta, C=sim$C),
eStep=list(M=sim$W, S=matrix(1e-4, n, q), xi=matrix(plogis(sim$X%*%sim$gamma), n, p)),
latent=list(U=sim$U, W=sim$W, Z=sim$Z, Yall=sim$Yall))
#############################################################
################ INIT ajustement SR
init <- InitZiPLN(data) #! Fichiers différnets pour miss et pas miss
